

!=================================================================!
! Do not change below this line unless you know what you are doing
!=================================================================!

eval($OT1_becomes="O")
eval($OT2_becomes="OXT")
eval($ile_CD_becomes="CD1")

evaluate ($count = 0)

!for $file in ( @@$filelist ) loop readpdb
eval($count=$count+1)
evaluate ($filename= $file - ".pdb" + "_conv.pdb")
evaluate ($psfname= $file - ".pdb" + "_conv.psf")

fileexist $filename end
evaluate ($convfileexist=$result)
if ($convfileexist eq false) then
dele sele=(all) end
struc reset end
noe reset end

segment
  chain
    convert=true
    separate=true
    @@$link_file
    coordinates @@$file
  end
end
do (name="CD1") (resname ILE and name CD)
do (name="O") (name OT1)
do (name="OXT") (name OT2)
delete sele=(hydrogen and attr charge = 0) end

coordinates @@$file

show sum(1) ( not(hydrogen) and not(known) )
if ( $select = 0 ) then
  display  %INFO: There are no coordinates missing for non-hydrogen atoms
end if

if ( $log_level = verbose ) then
  set message=normal echo=on end
else
  set message=off echo=off end
end if

if ( $auto_break = true ) then
  display test: autobreak
  evaluate ($break=0)

  for $id1 in id ( name C and bondedto(name CA) and bondedto(name O) ) loop break

    show (segid) (id $id1)
    evaluate ($segid1=$result)
    show (resid) (id $id1)
    evaluate ($resid1=$result)
    show (resname) (id $id1)
    evaluate ($resname1=$result)

    show sum(1) (id $id1 and known)
    if ( $result = 0 ) then
      display unknown coordinates for segid $segid1 resname $resname1 resid $resid1 name C
      display this coordinate must be known for automatic chain break detection
      abort
    end if

    identity (store1) ( name N and bondedto( segid $segid1 and resid $resid1 and name c ) )

    if ( $select = 1 ) then
      show element (store1) (attribute store1 > 0)
      evaluate ($id2=$result)
      show (segid) (id $id2)
      evaluate ($segid2=$result)
      show (resid) (id $id2)
      evaluate ($resid2=$result)
      show (resname) (id $id2)
      evaluate ($resname2=$result)

      show sum(1) (id $id2 and known)
      if ( $result = 0 ) then
        display unknown coordinates for segid $segid2 resname $resname2 resid $resid2 name N
        display this coordinate must be known for automatic chain break detection
        abort
      end if

      pick bond
        (name c and segid $segid1 and resid $resid1)
        (name n and segid $segid2 and resid $resid2)
        geometry

      if ( $result > $break_cutoff ) then
        evaluate ($break=$break+1)
        evaluate ($seg1.$break=$segid1)
        evaluate ($res1.$break=$resid1)
        evaluate ($seg2.$break=$segid2)
        evaluate ($res2.$break=$resid2)
        if ( $resname2 = PRO ) then
          evaluate ($patch.$break=DPPP)
        elseif ( $resname2 = CPR ) then
          evaluate ($patch.$break=DPPP)
        else
          evaluate ($patch.$break=DPEP)
        end if
      end if
    end if

  end loop break

  evaluate ($counter=1)

  while ($counter <= $break) loop delete
    patch $patch.$counter
      reference=-=(segid $seg1.$counter and resid $res1.$counter)
      reference=+=(segid $seg2.$counter and resid $res2.$counter)
    end
    evaluate ($counter=$counter+1)
  end loop delete

end if

eval($nchain = 0)

evaluate ($disu=0)

for $id1 in id ( resname CYS and name SG ) loop dis1
  display test: dis1 $id1

  show (segid) (id $id1)
  evaluate ($segid1=$result)
  show (resid) (id $id1)
  evaluate ($resid1=$result)

  identity (store1) (all)

  for $id2 in id ( resname CYS and name SG and
                ( attr store1 > $id1 ) ) loop dis2

    show (segid) (id $id2)
    evaluate ($segid2=$result)
    show (resid) (id $id2)
    evaluate ($resid2=$result)

    pick bond (id $id1) (id $id2) geometry

    if ( $result <= $disulphide_dist ) then
      evaluate ($disu=$disu+1)
      evaluate ($seg1.$disu=$segid1)
      evaluate ($seg2.$disu=$segid2)
      evaluate ($res1.$disu=$resid1)
      evaluate ($res2.$disu=$resid2)
    end if

  end loop dis2

end loop dis1

evaluate ($counter=1)
while ( $counter <= $disu ) loop disu
  display test: disu $counter
  patch disu
    reference=1=(segid $seg1.$counter and resid $res1.$counter)
    reference=2=(segid $seg2.$counter and resid $res2.$counter)
  end
  evaluate ($counter=$counter+1)
end loop disu

for $id in id ( known and not hydrogen and name ca and resname PRO) loop cisp

  show (segid) (id $id)
  evaluate ($segid=$result)
  show (resid) (id $id)
  evaluate ($resid=$result)
  show (resname) (id $id)
  evaluate ($resname=$result)

  identity (store1) ( known and not hydrogen and ( name c and bondedto
           ( name n and resid $resid and segid $segid ) ) )
  if ( $select = 1 ) then
    show element (store1) (attribute store1 > 0)
    evaluate ($id_prev=$result)
    show (segid) (id $id_prev)
    evaluate ($segid_prev=$result)
    show (resid) (id $id_prev)
    evaluate ($resid_prev=$result)
    show (resname) (id $id_prev)
    evaluate ($resname_prev=$result)

    pick dihedral
      (name ca and segid $segid_prev and resid $resid_prev)
      (name  c and segid $segid_prev and resid $resid_prev)
      (name  n and segid $segid and resid $resid)
      (name ca and segid $segid and resid $resid)
      geometry

    evaluate ($dihedral=mod($result+360,360))

    if ( $dihedral > 180 ) then
      evaluate ($dihedral=$dihedral-360)
    end if

    evaluate ($absdihedral=abs($dihedral))

    if ( $absdihedral < 25 ) then
      patch cisp reference=NIL=(segid $segid_prev and resid $resid_prev) end
      display CIS peptide bon detected for residue $resid_prev
    end if

  end if

end loop cisp

identity (store1) (none)

identity (store1) (not(known))

show sum(1) (store1)
evaluate ($tobuild=$result)

if ( $tobuild > 0 ) then

  fix selection=(not(store1)) end

  show sum(1) (store1)
  evaluate ($moving=$result)

  if ( $moving > 0 ) then
    for $id in id (tag and byres(store1)) loop avco

      show ave(x) (byres(id $id) and known)
      evaluate ($ave_x=$result)
      show ave(y) (byres(id $id) and known)
      evaluate ($ave_y=$result)
      show ave(z) (byres(id $id) and known)
      evaluate ($ave_z=$result)

      do (x=$ave_x) (byres(id $id) and store1)
      do (y=$ave_y) (byres(id $id) and store1)
      do (z=$ave_z) (byres(id $id) and store1)

    end loop avco

    do (x=x+random(2.0)) (store1)
    do (y=y+random(2.0)) (store1)
    do (z=z+random(2.0)) (store1)

    {- start parameter for the side chain building -}
    parameter
      nbonds
        rcon=20. nbxmod=-2 repel=0.9  wmin=0.1 tolerance=1.
        rexp=2 irexp=2 inhibit=0.5
      end
    end

    {- Friction coefficient, in 1/ps. -}
    do (fbeta=100) (store1)

    evaluate ($bath=300.0)
    evaluate ($nstep=500)
    evaluate ($timestep=0.0005)

    do (refy=mass) (store1)

    do (mass=20) (store1)

    igroup interaction
      (store1) (store1 or known)
    end

    {- turn on initial energy terms -}
    flags exclude * include bond angle vdw end

    minimize powell nstep=50  nprint=10 end

    do (vx=maxwell($bath)) (store1)
    do (vy=maxwell($bath)) (store1)
    do (vz=maxwell($bath)) (store1)

    flags exclude vdw include impr end

    dynamics cartesian
      nstep=50
      timestep=$timestep
      tcoupling=true temperature=$bath
      nprint=$nstep
      cmremove=false
    end

    flags include vdw end

    minimize powell nstep=50 nprint=10 end

    do (vx=maxwell($bath)) (store1)
    do (vy=maxwell($bath)) (store1)
    do (vz=maxwell($bath)) (store1)

    dynamics cartesian
      nstep=50
      timestep=$timestep
      tcoupling=true temperature=$bath
      nprint=$nstep
      cmremove=false
    end

    parameter
      nbonds
        rcon=2. nbxmod=-3 repel=0.75
      end
    end

    minimize powell nstep=100 nprint=25 end

    do (vx=maxwell($bath)) (store1)
    do (vy=maxwell($bath)) (store1)
    do (vz=maxwell($bath)) (store1)

    dynamics cartesian
      nstep=$nstep
      timestep=$timestep
      tcoupling=true temperature=$bath
      nprint=$nstep
      cmremove=false
    end

    {- turn on all energy terms -}
    flags include dihe ? end

    {- set repel to ~vdw radii -}
    parameter
      nbonds
        repel=0.89
      end
    end

    minimize powell nstep=500 nprint=50 end

    flag include elec end
    energy end
    flags exclude * include bond angl impr dihe vdw end

    {- return masses to something sensible -}
    do (mass=refy) (store1)

    do (vx=maxwell($bath)) (store1)
    do (vy=maxwell($bath)) (store1)
    do (vz=maxwell($bath)) (store1)

    dynamics cartesian
      nstep=$nstep
      timestep=$timestep
      tcoupling=true temperature=$bath
      nprint=$nstep
      cmremove=false
    end

    {- some final minimisation -}
    minimize powell
      nstep=500
      drop=40.0
      nprint=50
    end

    print thres=0.02 bonds
    print thres=5. angles

  end if

  fix selection=( none ) end

end if

if (&set_bfactor=true) then
  do (b=&bfactor) ( all )
else
  show ave(b) (known and not(store1))
  do (b=$result) (store1 and (attr b < 0.01))
end if

set remarks=reset end

{* ===================== turn on electrostatics *}

parameter
  nbonds
    nbxmod=5 atom cdie shift
    cutnb=9.5 ctofnb=8.5 ctonnb=6.5 eps=$epsilon e14fac=0.4 inhibit 0.5
    wmin=0.5
    tolerance  0.5
    repel=0.0
  end
end

flags excl * incl bond angl impr dihe vdw elec end

{* ===================== calculate free molecules internal energy *}

do (refx=x) (all)
do (refy=y) (all)
do (refz=z) (all)

! calc_free-ene.cns
!    Calculate the total energy of the separated components
!
! Script uses the store1 and store2 atom object, and COMP, REF and RMSD object
! ***********************************************************************
! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           *
! * All rights reserved.                                                *
! * This code is part of the HADDOCK software and governed by its       *
! * license. Please see the LICENSE file that should have been included *
! * as part of this package.                                            *
! ***********************************************************************
!
igroup

  eval($nchain1 = 0)

  while ($nchain1 < $data.ncomponents) loop nloop1
    eval($nchain1 = $nchain1 + 1)
  
    interaction (segid $Toppar.prot_segid_$nchain1) (segid $Toppar.prot_segid_$nchain1) weight * 1.0 end

 end loop nloop1

end

evaluate ($eintfree = 0.0)
! flex_segment_back.cns
!    Define the semi-flexible segments (both side-chains and backbone)
!
! ***********************************************************************
! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           *
! * All rights reserved.                                                *
! * This code is part of the HADDOCK software and governed by its       *
! * license. Please see the LICENSE file that should have been included *
! * as part of this package.                                            *
! ***********************************************************************
!

do (store5 = 0) (all)
do (store6 = 0) (all)
do (store7 = 0) (all)

!first flexible segments for docking
evaluate($nchain1 = 0)
while ($nchain1 < $data.ncomponents) loop nloop1
  evaluate($nchain1 = $nchain1 + 1)
  evaluate($nf=0)

  if ($Toppar.nseg_$nchain1 = 0) then
    display NO FLEXIBLE SEGMENTS for molecule $nchain1
  else
    if ($Toppar.nseg_$nchain1 < 0) then
      display AUTOMATIC DEFINITION OF FLEXIBLE SEGMENTS BASED ON INTERMOLECULAR PROXIMITY FOR MOLECULE $nchain1
! flexauto-neighbors.cns
!    Automatic definition of flexible segments for docking for contacting residues
!    including neighboring residues of residues making contacts
!
! ***********************************************************************
! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           *
! * All rights reserved.                                                *
! * This code is part of the HADDOCK software and governed by its       *
! * license. Please see the LICENSE file that should have been included *
! * as part of this package.                                            *
! ***********************************************************************
!

evaluate ($flcut = 5.0)

do (store5 = $nchain1) (byres (segid $Toppar.prot_segid_$nchain1 
                               and (not (segid $Toppar.prot_segid_$nchain1 or resn SHA)) around $flcut))
do (store7 = $nchain1) (byres (segid $Toppar.prot_segid_$nchain1 
                               and (not (segid $Toppar.prot_segid_$nchain1 or resn SHA)) around $flcut))

do (store6 = 0) (segid $Toppar.prot_segid_$nchain1)
for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres1
    show (resid) (id $id)
    evaluate ($inres = decode($result))
    evaluate ($preres = $inres)
    evaluate ($nexres = $inres)
    if ($iteration = 1) then
      evaluate ($preres = $preres - 1)
!      evaluate ($nexres = $nexres + 1)
    end if
    do (store6 = $nchain1) (resid $preres and segid $Toppar.prot_segid_$nchain1)
    do (store6 = $nchain1) (resid $nexres and segid $Toppar.prot_segid_$nchain1)
end loop flexres1

do (store5 = store6) (segid $Toppar.prot_segid_$nchain1)
do (store7 = store6) (segid $Toppar.prot_segid_$nchain1)

display THE FOLLOWING RESIDUES HAVE BEEN DEFINED AS FLEXIBLE for molecule $nchain1
for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2
    show (resid) (id $id)
    evaluate ($inres = $result)
    show (resn) (id $id)
    evaluate ($nares = $result)
    show (segid) (id $id)
    evaluate ($seres = $result)
    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres
end loop flexres2

    else
      display FLEXIBLE SIDE-CHAINS SEGMENTS for molecule $nchain1
      while ($nf < $Toppar.nseg_$nchain1) loop Xflex
        evaluate($nf=$nf + 1)
        do (store5 = $nchain1) ( resid $Toppar.start_seg_$nchain1_$nf : $Toppar.end_seg_$nchain1_$nf
                                 and segid $Toppar.prot_segid_$nchain1)
        display FLEXIBLE SEGMENT NR $nf FROM $Toppar.start_seg_$nchain1_$nf TO $Toppar.end_seg_$nchain1_$nf
      end loop Xflex
    end if
  end if
end loop nloop1

!then fully flexible segments for all stages
evaluate($nchain1 = 0)
while ($nchain1 < $data.ncomponents) loop nloop2
  evaluate($nchain1 = $nchain1 + 1)
  if ($Toppar.nfle_$nchain1 = 0) then
    display NO FULLY FLEXIBLE SEGMENTS for molecule $nchain1
  else
    display FULLY FLEXIBLE SEGMENTS for molecule $nchain1
    evaluate($nf=0)
    while ($nf < $Toppar.nfle_$nchain1) loop Xfflex
      evaluate($nf=$nf + 1)
      do (store5 = $nchain1) ( resid $Toppar.start_fle_$nchain1_$nf : $Toppar.end_fle_$nchain1_$nf
                               and segid $Toppar.prot_segid_$nchain1 )
      display FULLY FLEXIBLE SEGMENT NR $nf FROM $Toppar.start_fle_$nchain1_$nf TO $Toppar.end_fle_$nchain1_$nf
    end loop Xfflex
  end if
end loop nloop2

do (store5 = 21) (resn WAT or resn HOH or resn TIP*)
evaluate ($nfletot = 0)

! check number of flexible residues per molecule
evaluate($nchain1 = 0)
while ($nchain1 < $data.ncomponents) loop nloop3
  evaluate($nchain1 = $nchain1 + 1)
  do (store6 = 0) (all)
  do (store6 = 1) (tag and (attr store5 = $nchain1))
  show sum (store6) (all)
  evaluate ($numfle=$result)
  do (store6 = 0) (all)
  do (store6 = 1) (tag and segid $Toppar.prot_segid_$nchain1 and not (attr store5 = $nchain1))
  show sum (store6) (all)
  evaluate ($numrig=$result)
  do (store6 = 0) (all)
  do (store6 = 1) (tag and segid $Toppar.prot_segid_$nchain1)
  show sum (store6) (all)
  evaluate ($numres=$result)
  display FLEXIBILITY STATISTIC FOR MOLECULE $nchain1 : Nres=$numres Nrigid=$numrig Nflex=$numfle
  evaluate ($nfletot = $nfletot + $numfle)
end loop nloop3

do (store1 = 0) (all)
do (store1 = 1) ((resn WAT or resn HOH or resn TIP*) and name OH2)
show sum (store1) ((resn WAT or resn HOH or resn TIP*))
evaluate ($nfletot = $nfletot + $result)

evaluate ($nfletot = $nfletot + 10)
fix sele=(((attr store5 = 0) or resn ANI or resn DAN or resn XAN or resn SHA) and not name H* and not (resn WAT or resn HOH or resn TIP*)) end

minimize powell nstep=100 drop=10.0 nprint=25 end
fix sele=(not all) end
energy end
evaluate ($eintfree = $bond + $angl + $impr + $dihe + $vdw + $elec)

display FREE MOLECULES INTERNAL ENERGY = $eintfree


do (x=refx) (all)
do (y=refy) (all)
do (z=refz) (all)

{* ===================== minimize complex *}

parameter nbonds eps=$epsilon end end

fix selection=(not all) end

!  fix selection=(not(store1)) end
!  fix selection=(segid B or (name P or name N1 or name CA or name C or name N or name O)) end
minimize powell
  nstep=50
  drop=40.0
  nprint=50
end
fix selection=(not all) end

parameter nbonds eps=1.0 end end

! DISABLED in SIMPLE SCORING
{* ===================== calculate symmetry energy *}
!noe reset nres=10000 end
!@symmultimer.cns
!flag incl noe end
!noe
!  scale symm $Data.ksym
!end
!energy end
!evaluate ($esym = $noe)

! DISABLED in SIMPLE SCORING
{* ===================== calculate air energy *}
!noe
!      reset
!      nrestraints = 1000000   ! allocate space for NOEs
!      ceiling 100
!
!      set echo off message off end
!      class      unamb @@unambig.tbl
!      set echo on message on end
!
!      averaging  * sum
!      potential  * soft
!      scale      * 50.0
!      sqconstant * 1.0
!      sqexponent * 2
!      soexponent * 1
!      rswitch    * 1.0
!      sqoffset   * 0.0
!      asymptote  * 2.0
!
!      msoexponent * 1
!      masymptote  * -2.0
!      mrswitch    * 1.0
!
!      avexpo hbond 20
!end
!
!energy end
!evaluate ($air = $noe)
!print threshold=0.3 noe
!evaluate ($rms_noe=$result)
!evaluate ($violations_noe=$violations)

{* ===================== calculate complex internal energy *}
evaluate ($kinter = 1.0)
igroup

  eval($nchain1 = 0)

  while ($nchain1 < $data.ncomponents) loop nloop1
    eval($nchain1 = $nchain1 + 1)
  
    interaction (segid $Toppar.prot_segid_$nchain1) (segid $Toppar.prot_segid_$nchain1) weight * 1.0 end

 end loop nloop1

end


energy end
evaluate ($eintcplx = $bond + $angl + $impr + $dihe + $vdw + $elec)

{* ===================== calculate final energies and write structure *}
flag exclude * include elec vdw end
evaluate ($kinter = 1.0)

igroup interaction (not all) (not all) end

igroup

  eval($nchain1 = 0)

  while ($nchain1 < $data.ncomponents) loop nloop1
    eval($nchain1 = $nchain1 + 1)
    eval($nchain2 = $nchain1 )
    while ($nchain2 < $data.ncomponents) loop nloop2
      eval($nchain2 = $nchain2 + 1)
      interaction (segid $Toppar.prot_segid_$nchain1)
                  (segid $Toppar.prot_segid_$nchain2) weight * 1.0 vdw $kinter elec $kinter end
    end loop nloop2

 end loop nloop1

end


energy end
evaluate ($etot = $ener)

do (q=1.0) (all)
do (b=10) (all)
!$Revision: 1.3 $
!$Date: 2004/06/17 08:40:54 $
!$RCSfile: print_coorheader.cns,v $

! print_coorheader.cns
!     ************************************
!     * Authors and copyright:           *
!     * Michael Nilges, Jens Linge, EMBL *
!     * Adapted by Alexandre Bonvin      *
!     * Utrecht University               *
!     * No warranty implied or expressed *
!     * All rights reserved              *
!     ************************************


if ($Data.flags.dihed eq FALSE) then evaluate ($dihe = 0) end if
if ($Data.flags.sani  eq FALSE) then evaluate ($sani = 0) end if
if ($Data.flags.dani  eq FALSE) then evaluate ($dani = 0) end if
if ($Data.flags.coup  eq FALSE) then evaluate ($coup = 0) end if
if ($Data.flags.vean  eq FALSE) then evaluate ($vean = 0) end if
if ($Data.flags.cdih  eq FALSE) then evaluate ($cdih = 0) end if
if ($Data.flags.noe   eq FALSE) then evaluate ($noe  = 0) end if

evaluate($enerall=$etot)
evaluate($bondall=$bond)
evaluate($anglall=$angl)
evaluate($imprall=$impr)
evaluate($diheall=$dihe)
evaluate($vdwall=$vdw)
evaluate($elecall=$elec)
evaluate($noeall=$noe)
evaluate($cdihall=$cdih)
evaluate($coupall=$coup)
evaluate($saniall=$sani)
evaluate($veanall=$vean)
evaluate($daniall=$dani)

evaluate ($result=0)
evaluate ($violations=0)
print threshold=0.3 noe 
evaluate ($rms_noe=$result)
evaluate ($violations_noe=$violations)

if ($Data.noecv eq false) then
  evaluate ($violations_test_noe= 0)
  evaluate ($rms_test_noe = 0)
  evaluate ($npart = 0)
end if

evaluate ($result=0)
evaluate ($violations=0)
print threshold=5. cdih
evaluate ($rms_cdih=$result)
evaluate ($violations_cdih=$violations)
evaluate ($result=0)
print thres=0.05 bonds          
evaluate ($rms_bonds=$result)
evaluate ($result=0)
print thres=5. angles
evaluate ($rms_angles=$result)
evaluate ($result=0)
print thres=5. impropers
evaluate ($rms_impropers=$result)
evaluate ($result=0)
print thres=30. dihedrals 
evaluate ($rms_dihedrals=$result)
evaluate ($result=0)
evaluate ($violations=0)
coupl print thres=1.0 class * end
evaluate ($rms_coup = $result)
evaluate ($violations_coup = $violations)

evaluate ($result=0)
evaluate ($violations=0)
sani print threshold = 0.20 class rdc1 end
evaluate( $rms_sani = $result)
evaluate( $violations_sani = $violations)
evaluate ($result=0)
evaluate ($violations=0)
sani print threshold = 0.20 class rdc2 end
if ($result > 0) then
  evaluate( $rms_sani = (0.5 * $rms_sani) + (0.5 * $result))
end if
evaluate( $violations_sani = $violations_sani + $violations)
evaluate ($result=0)
evaluate ($violations=0)
sani print threshold = 0.20 class rdc3 end
if ($result > 0) then
  evaluate( $rms_sani = (0.5 * $rms_sani) + (0.5 * $result))
end if
evaluate( $violations_sani = $violations_sani + $violations)
evaluate ($result=0)
evaluate ($violations=0)
sani print threshold = 0.20 class rdc4 end
if ($result > 0) then
  evaluate( $rms_sani = (0.5 * $rms_sani) + (0.5 * $result))
end if
evaluate( $violations_sani = $violations_sani + $violations)
evaluate ($result=0)
evaluate ($violations=0)
sani print threshold = 0.20 class rdc5 end
if ($result > 0) then
  evaluate( $rms_sani = (0.5 * $rms_sani) + (0.5 * $result))
end if
evaluate( $violations_sani = $violations_sani + $violations)

if ($Data.flags.vean  eq TRUE) then
  evaluate ($result=0)
  evaluate ($violations=0)
  vean print threshold = 5.00 class vea1 end
  evaluate( $rms_vean = $result)
  evaluate( $violations_vean = $violations)
  evaluate ($result=0)
  evaluate ($violations=0)
  vean print threshold = 5.00 class vea2 end
  if ($result > 0) then
    evaluate( $rms_vean = (0.5 * $rms_vean) + (0.5 * $result))
  end if
  evaluate( $violations_vean = $violations_vean + $violations)
  evaluate ($result=0)
  evaluate ($violations=0)
  vean print threshold = 5.00 class vea3 end
  if ($result > 0) then
    evaluate( $rms_vean = (0.5 * $rms_vean) + (0.5 * $result))
  end if
  evaluate( $violations_vean = $violations_vean + $violations)
  evaluate ($result=0)
  evaluate ($violations=0)
  vean print threshold = 5.00 class vea4 end
  if ($result > 0) then
    evaluate( $rms_vean = (0.5 * $rms_vean) + (0.5 * $result))
  end if
  evaluate( $violations_vean = $violations_vean + $violations)
  evaluate ($result=0)
  evaluate ($violations=0)
  vean print threshold = 5.00 class vea5 end
  if ($result > 0) then
    evaluate( $rms_vean = (0.5 * $rms_vean) + (0.5 * $result))
  end if
  evaluate( $violations_vean = $violations_vean + $violations)
else
  evaluate( $rms_vean = 0)
  evaluate( $violations_vean = 0)
end if
  

if ($Data.flags.dani  eq TRUE) then
  evaluate ($result=0)
  evaluate ($violations=0)
  dani print threshold = 0.20 class dan1 end
  evaluate( $rms_dani = $result)
  evaluate( $violations_dani = $violations)
  evaluate ($result=0)
  evaluate ($violations=0)
  dani print threshold = 0.20 class dan2 end
  if ($result > 0) then
    evaluate( $rms_dani = (0.5 * $rms_dani) + (0.5 * $result))
  end if
  evaluate( $violations_dani = $violations_dani + $violations)
  evaluate ($result=0)
  evaluate ($violations=0)
  dani print threshold = 0.20 class dan3 end
  if ($result > 0) then
    evaluate( $rms_dani = (0.5 * $rms_dani) + (0.5 * $result))
  end if
  evaluate( $violations_dani = $violations_dani + $violations)
  evaluate ($result=0)
  evaluate ($violations=0)
  dani print threshold = 0.20 class dan4 end
  if ($result > 0) then
    evaluate( $rms_dani = (0.5 * $rms_dani) + (0.5 * $result))
  end if
  evaluate( $violations_dani = $violations_dani + $violations)
  evaluate ($result=0)
  evaluate ($violations=0)
  dani print threshold = 0.20 class dan5 end
  if ($result > 0) then
    evaluate( $rms_dani = (0.5 * $rms_dani) + (0.5 * $result))
  end if
  evaluate( $violations_dani = $violations_dani + $violations)
else
  evaluate( $rms_dani = 0)
  evaluate( $violations_dani = 0)
end if
  
{====>} {* define ASA-based solvation parameters *}
!
! Define atomic solvation parameters taken from Fernandez-Recia et al. JMB 335:843 (2004)
!
evaluate ($arofac = 6.26)
evaluate ($alifac = 1.27)
evaluate ($polfac = 2.30)
do (store1 =  0.0000) (all)
do (store1 =  0.0151 * $alifac) (name C*)
do (store1 =  0.0176 * $arofac) ((name CG* or name CD* or name CE* or name CH* or name CZ*) and (resn PHE or resn TYR or resn HIS or resn TRP))
do (store1 = -0.0170 * $polfac) (name N*)
do (store1 = -0.0548 * $polfac) (name NT* or (name NZ* and resn LYS))
do (store1 = -0.0273 * $polfac) (name NH* and resn ARG)
do (store1 = -0.0136 * $polfac) (name O*)
do (store1 = -0.0185 * $polfac) (name OG* or name OH)
do (store1 = -0.0299 * $polfac) ((name OD* and resn ASP) or (name OE* and resn GLU))
do (store1 =  0.0112 * $polfac) (name S*)
do (store1 =  0.0022 * $polfac) ((name S* and attr charge = -0.3) or (name SD and resn MET))

{====>} {* buried surface area *}
evaluate ($nchain1 = 1)
evaluate ($saafree = 0)
while ($nchain1 <= $data.ncomponents) loop nloop1
  {====>} {* buried surface area *}
  do (rmsd = 0) (all)
  surface mode=access accu=0.075 rh2o=1.4 sele=(segid $Toppar.prot_segid_$nchain1 and not (resn TIP3 or resn DMS)) end
  show sum (rmsd) (segid $Toppar.prot_segid_$nchain1 and not (resn TIP3 or resn DMS))
  evaluate ($saafree = $saafree + $result)
  evaluate ($nchain1 = $nchain1 + 1)
end loop nloop1
     
do (rmsd = 0) (all)
do (store2 = 0) (all)
surface mode=access accu=0.075 rh2o=1.4 sele=(not (resn TIP3 or resn DMS)) end
show sum (rmsd) (not (resn TIP3 or resn DMS))
evaluate ($satot = $result)
do (store2 = rmsd * store1) (not (resn TIP3 or resn DMS))
show sum (store2) (not (resn TIP3 or resn DMS))
evaluate ($esolcplx = $result)
evaluate ($saburied = $saafree - $satot)
evaluate ($edesolv = $esolcplx - $esolfree)
evaluate ($dhbinding = $edesolv + $eintcplx - $eintfree + $elec + $vdw)
display COMPLEX dH OF BINDING = $dhbinding

if ($Data.flags.sym eq true) then
  evaluate ($enerall = $enerall + $esym)
end if
if ($Data.flags.ncs eq true) then
  evaluate ($enerall = $enerall + $ncs)
end if

if ($data.waterdock eq true) then
  ident (store3) (not all)
  flag exclude * include vdw elec  end
  
  eval($nchain1 = 0)
 
  while ($nchain1 < $data.ncomponents) loop nloop1
    eval($nchain1 = $nchain1 + 1)
   
    igroup
      interaction (segid $Toppar.prot_segid_$nchain1) (resn TIP3 and not store3) weight * 1.0 end
      interaction (not segid $Toppar.prot_segid_$nchain1) (resn TIP3) weight * 0.0 end
      interaction (segid $Toppar.prot_segid_$nchain1) (not (resn TIP3 and store3)) weight * 0.0 end
    end
    energy end
    evaluate ($ener_water_$nchain1 = $ener)
    evaluate ($enerall = $enerall + $ener)
    evaluate ($vdw_water_$nchain1 = $vdw)
    evaluate ($elec_water_$nchain1 = $elec)
   
  end loop nloop1
  if ($data.ncomponents < 6) then
    eval($nchain1 = $data.ncomponents)
    while ($nchain1 < 6) loop nloop1
      eval($nchain1 = $nchain1 + 1)
      evaluate ($ener_water_$nchain1 = 0.0)
      evaluate ($vdw_water_$nchain1 = 0.0)
      evaluate ($elec_water_$nchain1 = 0.0)
    end loop nloop1
  end if

  eval($nchain1 = 0)

  igroup
    while ($nchain1 < $data.ncomponents) loop nloop2
      eval($nchain1 = $nchain1 + 1)
      interaction (segid $Toppar.prot_segid_$nchain1) (all) weight * 0.0 end
    end loop nloop2
    interaction (resn TIP3 and not store3) (resn TIP3 and not store3)  weight * 1.0 end
    interaction (store3) (store3)  weight * 0.0 end
  end
  energy end
  evaluate ($ener_water_water = $ener)
  evaluate ($enerall = $enerall + $ener)
  evaluate ($vdw_water_water = $vdw)
  evaluate ($elec_water_water = $elec)
else
  eval($nchain1 = 0)

  while ($nchain1 < 6) loop nloop1
    eval($nchain1 = $nchain1 + 1)
    evaluate ($ener_water_$nchain1 = 0.0)
    evaluate ($vdw_water_$nchain1 = 0.0)
    evaluate ($elec_water_$nchain1 = 0.0)
  end loop nloop1
  evaluate ($ener_water_water = 0.0)
  evaluate ($vdw_water_water = 0.0)
  evaluate ($elec_water_water = 0.0)
end if


remarks =============================================================== 
remarks HADDOCK run for $filename
remarks =============================================================== 
remarks            total,bonds,angles,improper,dihe,vdw,elec,noe,cdih,coup,sani,vean,dani
remarks energies: $enerall, $bondall, $anglall, $imprall, $diheall, $vdwall, $elecall, $noeall, $cdihall, $coupall, $saniall, $veanall, $daniall
remarks =============================================================== 
remarks            bonds,angles,impropers,dihe,noe,cdih,coup,sani,vean,dani
remarks rms-dev.: $rms_bonds,$rms_angles,$rms_impropers,$rms_dihedrals,$rms_noe,$rms_cdih,$rms_coup, $rms_sani, $rms_vean, $rms_dani
remarks =============================================================== 
remarks               noe,cdih,coup,sani,vean,dani
remarks               >0.3,>5,>1,>0,>5,>0.2
remarks violations.: $violations_noe, $violations_cdih, $violations_coup, $violations_sani, $violations_vean, $violations_dani
remarks ===============================================================
remarks                        CVpartition#,violations,rms
remarks AIRs cross-validation: $npart, $violations_test_noe, $rms_test_noe
remarks ===============================================================
remarks NCS energy: $ncs
remarks ===============================================================
remarks Symmetry energy: $esym
remarks =============================================================== 
remarks Desolvation energy: $edesolv 
remarks Internal energy free molecules: $eintfree
remarks Internal energy complex: $eintcplx
remarks Binding energy: $dhbinding
remarks =============================================================== 
remarks buried surface area: $saburied
remarks =============================================================== 
remarks water - chain1: $ener_water_1 $vdw_water_1 $elec_water_1
remarks water - chain2: $ener_water_2 $vdw_water_2 $elec_water_2
remarks water - chain3: $ener_water_3 $vdw_water_3 $elec_water_3
remarks water - chain4: $ener_water_4 $vdw_water_4 $elec_water_4
remarks water - chain5: $ener_water_5 $vdw_water_5 $elec_water_5
remarks water - chain6: $ener_water_6 $vdw_water_6 $elec_water_6
remarks =============================================================== 
remarks water - water: $ener_water_water $vdw_water_water $elec_water_water
remarks =============================================================== 



coor sele= (segid $Toppar.prot_segid_1) orient end
write coordinates sele= (all) output =$filename end
write structure output =$psfname end

end if

stop

"""
HADDOCK 3 supported residues.

https://bianca.science.uu.nl/haddock2.4/library


Write decent documentation .-)
"""
import itertools as it
import re
import string
from copy import copy

from haddock import PrePath, toppar_path



class CNSTopologyResidue:
    def __init__(self, resname, charge, atoms):
        self._resname = resname
        self._charge = round(charge, 2)
        self._atoms = tuple(atoms)
        return

    def __repr__(self):
        return str(self)

    def __str__(self):
        return f"{self.__class__.__name__}({self.resname!r}, {self.charge!r}, {self.atoms!r})"

    @property
    def resname(self):
        return self._resname

    @property
    def charge(self):
        return self._charge

    @property
    def atoms(self):
        return self._atoms

    @property
    def elements(self):
        return self._elements

    def make_elements(self, n=1):
        """."""
        ele = [a.rstrip(string.digits + "+-")[:n] for a in self.atoms]
        self._elements = tuple(ele)
        return



def read_residues_from_top(topfile):
    """."""
    atom_regex = r"^ATOM +([A-Z0-9\'\+\-]{1,4}) +.* +(?:charge|CHARGE|CHARge) *= *([\-|+]?\d+.?\d*).*(?:END|end).*$"
    residues = []
    atoms = []
    charges = []
    in_residue = False
    # just to avoid identention with with
    fin = open(topfile, 'r')
    lines = map(str.strip, fin)
    for line in lines:
        if line.startswith(('RESI', 'residue')):
            # I prefer to have this when a new residue starts than
            in_residue = True
            resname = line.split()[1]
            if atoms or charges:
                print(topfile)
                emsg = \
                    "Starting a new residue without emptying the previous one."
                raise ValueError(emsg)

        elif line.startswith('ATOM'):
            try:
                aname, acharge = re.findall(atom_regex, line)[0]
            except:
                print(line)
                raise
            atoms.append(aname)
            charges.append(acharge)

        elif line.startswith(("end", "END")) and in_residue:
            in_residue = False
            resi = CNSTopologyResidue(
                resname,
                sum(map(float, charges)),
                copy(atoms),
                )
            charges.clear()
            atoms.clear()
            residues.append(resi)

    fin.close()
    return residues


#def read_supported_residues_from_top_file(topfile, regex, Residue):
#    """
#    Read residue from CNS topology file.
#
#    Generic implementation.
#
#    Parameters
#    ----------
#    topfile : str or pathlib.Path
#        The path pointing to the HADDOCK `.top` file.
#
#    regex : raw string
#        The regex string to find the desired groups.
#
#    Residue : namedtuple
#        A named tuple that accepts arguments matching the groups
#        generated by `re.findall(regex, topfile)`.
#        For the implementation in this module we expect this Residue
#        namedtuple has a `resname` and `name` parameters, though it is
#        not mandatory.
#
#    Returns
#    -------
#    tuple
#        A tuple of Residue named tuples.
#    """
#    text = Path(topfile).read_text()
#    groups = re.findall(regex, text)
#    # transform_to_list is needed because some regex may return groups
#    # of just one members, hence the `for g in groups` returns a string
#    # instead of a list.
#    residues = tuple(Residue(*transform_to_list(g)) for g in groups)
#    return residues
#
#
#read_top = partial(partial, read_supported_residues_from_top_file)


# what we will need to inspect if the residues are allowed or not are
# the residue names. So it is nice to have a function that retrieve them
# from the respective named tuples.
def get_resnames(group):
    """Make a dictionary where keys are resnames and values the Residues."""
    return {i.resname: i for i in group}


TopparPath = PrePath(toppar_path)

# paths to the `.top` files
carbo_top = TopparPath("carbohydrate.top")
dna_rna_all_top = TopparPath("dna-rna-allatom-hj-opls-1.3.top")
dna_rna_martini_top = TopparPath("dna-rna-CG-MARTINI-2-1p.top")
fragment_top = TopparPath("fragment_probes.top")
hemes_top = TopparPath("hemes-allhdg.top")
ions_top = TopparPath("ion.top")
protein_5_4_top = TopparPath("protein-allhdg5-4.top")
protein_martini_2_top = TopparPath("protein-CG-Martini-2-2.top")
protein_martini_top = TopparPath("protein-CG-Martini.top")
solvent_top = TopparPath("solvent-allhdg5-4.top")


# supported Residues (tuple of namedtuples)
supported_carbohydrates = read_residues_from_top(carbo_top)
supported_nucleic = set(it.chain(
    read_residues_from_top(dna_rna_all_top),
    read_residues_from_top(dna_rna_martini_top),
    ))
supported_fragments = read_residues_from_top(fragment_top)
supported_hemes = read_residues_from_top(hemes_top)

supported_ions = read_residues_from_top(ions_top)  # aqui tiene los dos ions
supported_single_ions = tuple(ion for ion in supported_ions if len(ion.atoms) == 1)
supported_multiatom_ions = tuple(ion for ion in supported_ions if len(ion.atoms) > 1)

supported_aminoacids = set(it.chain(
    read_residues_from_top(protein_5_4_top),
    read_residues_from_top(protein_martini_2_top),
    read_residues_from_top(protein_martini_top),
    ))
supported_solvents = read_residues_from_top(solvent_top)

# supported resnames
supported_carbo_resnames = get_resnames(supported_carbohydrates)
supported_nucleic_resnames = get_resnames(supported_nucleic)
supported_fragments_resnames = get_resnames(supported_fragments)
supported_hemes_resnames = get_resnames(supported_hemes)
supported_ions_resnames = get_resnames(supported_ions)
supported_multiatom_ions_resnames = get_resnames(supported_multiatom_ions)
supported_aminoacids_resnames = get_resnames(supported_aminoacids)
supported_solvents_resnames = get_resnames(supported_solvents)

# other attributes
for ion in supported_single_ions:
    ion.make_elements(n=2)
supported_ions_elements = {ion.elements[0]: ion for ion in supported_single_ions}

print(supported_ions_elements)
supported_ions_atoms = {ion.atoms: ion for ion in supported_ions}

#
# Residues that must be set as ATOM
supported_ATOM = set(it.chain(
    supported_nucleic_resnames,
    supported_aminoacids_resnames,
    ))

# Residues that must be set as HETATM
supported_HETATM = set(it.chain(
    supported_carbo_resnames,
    supported_fragments_resnames,
    supported_hemes_resnames,
    supported_ions_resnames,
    supported_multiatom_ions_resnames,
    supported_solvents_resnames,
    ))
